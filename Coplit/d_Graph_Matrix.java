package Coplit;

import java.util.Arrays;

public class d_Graph_Matrix {
    public static void main(String[] args) {
        int[][] x = new int[][] {
                {0, 3, 0},
                {0, 2, 0},
                {1, 3, 0},
                {2, 1, 0}
        };
        System.out.println(Arrays.deepToString(createMatrix(x)));
    }
    public static int[][] createMatrix(int[][] edges) {
        // 그래프 크기 지정
        // int[][] graph = new int[edges.length][edges.length];
        // 아니지 요소의 값 중 가장 큰 값까지 버텍스가 있는거니까
        // 이중 배열 인덱스마다 순회해서 가장 큰 값을 vMax 에 저장
        int vMax = 0;
        for (int i = 0; i < edges.length; i++) {
            for (int j = 0; j < edges[i].length; j++) {
                if (vMax < edges[i][j]) vMax = edges[i][j];
            }
        }
        // 그래프 크기는 0 ~ vMax 니까 0 때문에 +1 해줌
        int[][] graph = new int[vMax + 1][vMax + 1];

        // 다시 배열 길이 만큼 순회해서 시작점, 도착점, 방향 뽑아줘야함
        for (int[] edge : edges) {
            // 엣지 시작점
            int from = edge[0];
            // 엣지 도착점
            int to = edge[1];
            // 방향 제시
            int dir = edge[2];
            // 문제에서 1은 쌍방통행, 0은 일방통행 이라고 주어졌으니 분기해줘야함
            // 단, 위의 변수에서 뽑을 때마다 graph 에 저장해주어야 하기 때문에
            // 분기 설정은 포문 안에서 해야함
            if (dir == 0) {
                // 조건이 일방통행 = from 과 to 사이의 엣지 1
                graph[from][to] = 1;
            } else if (dir == 1) {
                // 조건이 쌍방통행 = from 과 to 사이의 엣지 2
                // 표 형식으로 만들어지기 때문에 합치는건 아님
                graph[from][to] = 1;
                graph[to][from] = 1;
                // 생성된 2중 배열 graph 에 각각 해당하는 값 넣고 끝
            }
        }
        return graph;
    }
}
// 그래프 형태에서 연결되어있는 노드들의 엣지가 인접해있는걸 표로 나타내야하는건 알겠는데
// 그 노드들이 뭐랑 뭐가 연결되어있는지 모르겠음
// 당장 위의 배열만 봐도 모르겠는디;
// 3,2,1 이 각각 노드고 양 옆이 연결되었는가 안되었는가인가?
// 간선 연결 기준을 모르겠음

// 검색 : 자바 인접행렬 생성 X
// https://sskl660.tistory.com/60
// 기본적으로 인접행렬을 이용한 그래프 표현은 각 인덱스를 정점이라고 생각하고,
// 정점이 교차하는 지점(좌표)을 연결된 상태라고 표시
// 아니 근데 왜 안쪽 배열의 값들이 뭐에 해당하는지가 없네 전부
// 검색 : 자바 이중배열 인접행렬 노드 X

// 리퍼런스
// 만약, [0, 3, 0]가 들어왔다면,
// 만들어 둔 result의 0 번째 row에 3 번째 col에 1을 추가합니다.
// [ 0, 0, 0, 1 ] => 0번째 버텍스가 갈 수 있는 간선 중, 3 번으로 가는 간선만 갈 수 있습니다.
// 이거 보니까 느낌 올거같은데...

// 그러니까 정리하면 배열의 인덱스가 버텍스고
// 이 문제는 해당 버텍스 간에 엣지가 있으면 1 없으면 0 으로 표현한
// 표를 만드는 건데
// 여기서 엣지가 있는지 없는지 판단을 어떻게 함?

// https://charlie-junbeom-94043.tistory.com/37
// adjs[i][j] 를 통해서 해당 값에 접근을 하면 이 값은 노드 i 에서 j 로 가는 간선의 유무를 나타냅니다.
// 이게 뭐지

// 아 이거
// 문제에서 주어는 배열의 요소 중에서
// 0번 인덱스랑 1번 인덱스가 각각 버텍스
// 2번 인덱스의 0과 1이 각각 일방통행, 쌍방통행
// 0번 인덱스 1번 인덱스 중 가장 큰 값의 수만큼 버텍스 존재
// 이거네
// 내가 간선의 기준을 찾아서 넣는게 아니라 간선이 이미 주어진 문제였음

//            for (int i = 0; i < edges.length; i++){
//            // 안쪽 배열 순회
//            for (int j = 0; j < edges[i].length; j++) {
//                // 0번째 안쪽 배열일 때 0 3 0 순회 ~> 0 -> 3 -> 0
//                // edges[0][0] / edges[0][3] / edges[0][0]
//                // 1번째 안쪽 배열일 때 0 2 0 순회 ~> 0 -> 2 -> 0
//                // edges[1][0] / edges[1][2] / edges[1][0]
//                // 2번째 안쪽 배열일 때 1 3 0 순회 ~> 1 -> 3 -> 0
//                // edges[2][1] / edges[2][3] / edges[2][0]
//                // 3번째 안쪽 배열일 때 2 1 0 순회 ~> 2 -> 1 -> 0
//                // edges[3][2] / edges[3][1] / edges[3][0]
//
//                // edges[i][j]: 노드 i에서 노드 j로 가는 간선이 있으면 1, 없으면 0
//                // ~> 근데 이걸 어떻게 판단함?
//                // 일단은 노드가 배열의 인덱스인건 알겠음
//                // 그럼 노드가 0 1 2 3 이 있다는 뜻

// 해냈다 했냈어 진짜 죽는줄알았네 ㅋㅋㅋㅋㅋㅋㅋ